# go-bootcamp
Geekbang Go Basic Bootcamp

## v0.0.5

> 设计一个新的容错机制，同步转异步的容错机制。当满足以下两个条件中的任何一个时，将请求转储到数据库，后续再另外启动一个 goroutine 异步发送出去。

审错题了！没看到“后续再”。。。于是我在注册服务的时候就生成了一个goroutine循环查看数据库是否有未发送消息，如果有就尝试逐条发送。
这样做的坏处是不是严格的间隔，可能一个请求失败并不会等到约定的时间，而是在约定时间之前就会被重试，不过这样问题也不大。如果每一个请求失败都启动一个goroutine，或许会产生大量的goroutines等到第三方一恢复全部冲过去发送再次激发限流？
不过我也没有处理这个问题，但是单协程可能会好处理一些，只需要根据限流参数算出来一个延时，在每次成功之后进行下一个之前等待即可逐一发送库存里的请求，并不触发limit。


> 要求：
>
>    如何判定服务商已经崩溃，不允许使用课程上的判断机制，你需要设计一个新的判断机制，并且解释这种判定机制的决策理由。

我选择的判断机制是找到某几个特征错误码，然后如果出现这几个错误码就判断服务商崩溃，比如Internal error, 或者服务器忙之类的错误码。这个可以通过事先询问第三方或者查询文档获得。其余的错误码可能是我们这一侧的问题，比如API过期之类的，重试也没用，直接返回错误停掉。


>    控制异步重试次数，转储到数据库之后，可以重试 N 次，重试间隔你可以自由决策。
>    不允许写死任何参数，即用户必须可以控制控制参数。
>    保持面向接口和依赖注入风格。

应该基本完成了要求。

>    写明这种容错机制适合什么场景，并且有什么优缺点。

这种容错机制适合不太需要即时响应的情况。

优点是解耦服务，方便日后拆分，登陆的归登陆，短信的归短信。
缺点是对于需要即时响应的服务可能会造成不便，以及对于本身就很快很稳的服务或许造成不必要的延时。

>    针对提出的缺点，写出后续的改进方案。

改进方案是使用更专业吞吐量更大的专业消息队列中间件，而不是持久型数据库。

>    提供单元测试。

想测好真不容易，还提供了一个集成测试。

>    设计方案的时候，不允许问老师、助教。即方案肯定得你自己设计，包括优缺点分析、改进方向必须独立完成。

独立完成，几乎没有请教AI。

## TODO

- [X] Rate limiter middleware
- [ ] Unit tests
